/**
 * Requirements Output JSON Schema
 *
 * Defines and validates the structure of requirements generated by the Product Owner agent
 */

const { z } = require('zod');

// Feature Schema
const FeatureSchema = z.object({
  name: z.string().min(1).describe('Feature name'),
  description: z.string().min(1).describe('Detailed feature description'),
  user_story: z.string().min(1).describe('User story in "As a... I want... So that..." format'),
  acceptance_criteria: z.array(z.string()).min(1).describe('Testable acceptance criteria'),
  technical_considerations: z.array(z.string()).optional().describe('Technical implementation notes'),
  effort_estimate: z.enum(['small', 'medium', 'large', 'x-large']).describe('T-shirt size estimate'),
  dependencies: z.array(z.string()).optional().describe('Dependencies on other features or systems')
});

// Capability Schema
const CapabilitySchema = z.object({
  name: z.string().min(1).describe('Business capability name'),
  description: z.string().min(1).describe('Capability description'),
  business_value: z.string().min(1).describe('Business value proposition'),
  priority: z.enum(['critical', 'high', 'medium', 'low']).describe('Business priority'),
  features: z.array(FeatureSchema).min(1).describe('Features implementing this capability')
});

// Domain Schema
const DomainSchema = z.object({
  name: z.string().min(1).describe('Domain/bounded context name'),
  description: z.string().min(1).describe('Domain description'),
  bounded_context: z.string().min(1).describe('DDD bounded context identifier'),
  capabilities: z.array(CapabilitySchema).min(1).describe('Business capabilities in this domain'),
  entities: z.array(z.string()).optional().describe('Core domain entities'),
  value_objects: z.array(z.string()).optional().describe('Domain value objects'),
  aggregates: z.array(z.string()).optional().describe('Domain aggregates')
});

// Application Schema
const ApplicationSchema = z.object({
  name: z.string().min(1).describe('Application name'),
  description: z.string().min(1).describe('Application description'),
  type: z.string().min(1).describe('Application type (web, mobile, api, etc.)'),
  industry: z.string().min(1).describe('Target industry'),
  target_users: z.array(z.string()).min(1).describe('Target user personas')
});

// Non-Functional Requirements Schema
const NonFunctionalRequirementsSchema = z.object({
  performance: z.array(z.string()).optional().describe('Performance requirements'),
  security: z.array(z.string()).optional().describe('Security requirements'),
  scalability: z.array(z.string()).optional().describe('Scalability requirements'),
  usability: z.array(z.string()).optional().describe('Usability requirements'),
  compliance: z.array(z.string()).optional().describe('Compliance requirements')
});

// MVP Scope Schema
const MVPScopeSchema = z.object({
  included_features: z.array(z.string()).min(1).describe('Features included in MVP'),
  excluded_features: z.array(z.string()).optional().describe('Features excluded from MVP'),
  timeline: z.string().min(1).describe('Estimated timeline for MVP')
});

// Complete Requirements Schema
const RequirementsSchema = z.object({
  application: ApplicationSchema,
  domains: z.array(DomainSchema).min(1).max(10).describe('Application domains (bounded contexts)'),
  non_functional_requirements: NonFunctionalRequirementsSchema,
  technical_constraints: z.array(z.string()).optional().describe('Technical constraints'),
  assumptions: z.array(z.string()).optional().describe('Project assumptions'),
  risks: z.array(z.string()).optional().describe('Identified risks'),
  success_metrics: z.array(z.string()).optional().describe('Success metrics/KPIs'),
  mvp_scope: MVPScopeSchema
});

// Output wrapper schema
const RequirementsOutputSchema = z.object({
  requirements: RequirementsSchema,
  metadata: z.object({
    generated_at: z.string(),
    generator: z.string(),
    version: z.string(),
    model_used: z.string()
  }),
  statistics: z.object({
    domains_count: z.number(),
    total_capabilities: z.number(),
    total_features: z.number(),
    mvp_features: z.number()
  })
});

/**
 * Validate requirements against schema
 */
function validateRequirements(data) {
  try {
    const result = RequirementsOutputSchema.parse(data);
    return { valid: true, data: result, errors: [] };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        valid: false,
        errors: error.errors.map(e => ({
          path: e.path.join('.'),
          message: e.message
        }))
      };
    }
    return {
      valid: false,
      errors: [{ path: 'unknown', message: error.message }]
    };
  }
}

/**
 * Generate example requirements (for testing)
 */
function generateExampleRequirements() {
  return {
    requirements: {
      application: {
        name: 'E-Commerce Platform',
        description: 'Online marketplace for handmade crafts',
        type: 'web',
        industry: 'Retail',
        target_users: ['Buyers', 'Sellers', 'Administrators']
      },
      domains: [
        {
          name: 'Product Catalog',
          description: 'Manages product listings and inventory',
          bounded_context: 'CatalogContext',
          capabilities: [
            {
              name: 'Product Management',
              description: 'Create and manage product listings',
              business_value: 'Enable sellers to showcase products',
              priority: 'critical',
              features: [
                {
                  name: 'Product Creation',
                  description: 'Allow sellers to create new product listings',
                  user_story: 'As a seller, I want to create product listings so that I can sell my items',
                  acceptance_criteria: [
                    'Product must have title, description, price, and photos',
                    'Support multiple product variations (size, color)',
                    'Draft and published states'
                  ],
                  technical_considerations: ['Image optimization', 'SEO-friendly URLs'],
                  effort_estimate: 'large',
                  dependencies: ['User authentication']
                }
              ]
            }
          ],
          entities: ['Product', 'Category', 'Inventory'],
          value_objects: ['Price', 'SKU', 'ProductImage'],
          aggregates: ['ProductAggregate']
        },
        {
          name: 'Order Management',
          description: 'Handles order processing and fulfillment',
          bounded_context: 'OrderContext',
          capabilities: [
            {
              name: 'Checkout Process',
              description: 'Shopping cart and payment processing',
              business_value: 'Convert browsing to sales',
              priority: 'critical',
              features: [
                {
                  name: 'Shopping Cart',
                  description: 'Add items to cart and manage quantities',
                  user_story: 'As a buyer, I want to add items to my cart so that I can purchase multiple items',
                  acceptance_criteria: [
                    'Add/remove items from cart',
                    'Update quantities',
                    'Calculate totals with tax and shipping'
                  ],
                  effort_estimate: 'medium',
                  dependencies: ['Product Catalog']
                }
              ]
            }
          ],
          entities: ['Order', 'Cart', 'Payment'],
          value_objects: ['OrderTotal', 'ShippingAddress'],
          aggregates: ['OrderAggregate']
        }
      ],
      non_functional_requirements: {
        performance: ['Page load time < 2 seconds', '99.9% uptime'],
        security: ['PCI DSS compliance for payments', 'SSL/TLS encryption'],
        scalability: ['Support 10,000 concurrent users', 'Auto-scaling infrastructure'],
        usability: ['Mobile responsive design', 'Accessibility WCAG 2.1 AA'],
        compliance: ['GDPR compliance', 'CCPA compliance']
      },
      technical_constraints: [
        'AWS cloud infrastructure',
        'React frontend',
        'Node.js backend',
        'PostgreSQL database'
      ],
      assumptions: [
        'Users have internet access',
        'Sellers handle their own shipping'
      ],
      risks: [
        'Payment gateway downtime',
        'Seasonal traffic spikes'
      ],
      success_metrics: [
        'GMV > $1M in first year',
        'Customer satisfaction > 4.5/5',
        'Seller retention > 80%'
      ],
      mvp_scope: {
        included_features: [
          'Product listings',
          'Shopping cart',
          'Basic checkout',
          'User registration'
        ],
        excluded_features: [
          'Advanced analytics',
          'Mobile app',
          'International shipping'
        ],
        timeline: '3 months'
      }
    },
    metadata: {
      generated_at: new Date().toISOString(),
      generator: 'product-owner-agent',
      version: '1.0.0',
      model_used: 'example-generator'
    },
    statistics: {
      domains_count: 2,
      total_capabilities: 2,
      total_features: 2,
      mvp_features: 4
    }
  };
}

module.exports = {
  RequirementsSchema,
  RequirementsOutputSchema,
  validateRequirements,
  generateExampleRequirements,
  // Export individual schemas for reuse
  FeatureSchema,
  CapabilitySchema,
  DomainSchema,
  ApplicationSchema
};